/*globals define*/
/*jshint node:true, browser:true*/

/**
 * Generated by PluginGenerator 1.7.0 from webgme on Sat Oct 15 2016 11:23:34 GMT-0500 (Central Daylight Time).
 * A plugin that inherits from the PluginBase. To see source code documentation about available
 * properties and methods visit %host%/docs/source/PluginBase.html.
 */

define([
    'plugin/PluginConfig',
    'text!./metadata.json',
    'plugin/PluginBase'
], function (PluginConfig,
             pluginMetadata,
             PluginBase) {
    'use strict';

    pluginMetadata = JSON.parse(pluginMetadata);

    /**
     * Initializes a new instance of RTCparser.
     * @class
     * @augments {PluginBase}
     * @classdesc This class represents the plugin RTCparser.
     * @constructor
     */
    var RTCparser = function () {
        // Call base class' constructor.
        PluginBase.call(this);
        this.pluginMetadata = pluginMetadata;
    };

    /**
     * Metadata associated with the plugin. Contains id, name, version, description, icon, configStructue etc.
     * This is also available at the instance at this.pluginMetadata.
     * @type {object}
     */
    RTCparser.metadata = pluginMetadata;

    // Prototypical inheritance from PluginBase.
    RTCparser.prototype = Object.create(PluginBase.prototype);
    RTCparser.prototype.constructor = RTCparser;

    /**
     * Main function for the plugin to execute. This will perform the execution.
     * Notes:
     * - Always log with the provided logger.[error,warning,info,debug].
     * - Do NOT put any user interaction logic UI, etc. inside this method.
     * - callback always has to be called even if error happened.
     *
     * @param {function(string, plugin.PluginResult)} callback - the result callback
     */

    RTCparser.prototype.main = function (callback) {
        // Use self to access core, project, result, logger etc from PluginBase.
        // These are all instantiated at this point.
        var self = this,
            nodeObject;

        nodeObject = self.activeNode;

        var artifact;
        self.loadNodeMap(self.rootNode)
            .then(function (nodes) {
                var instFile = self.getInst(self.rootNode, nodes);
                self.logger.info(instFile);
                artifact = self.blobClient.createArtifact('project-data');
                return artifact.addFile('MPA_example.m', instFile);
            })
            .then(function (fileHash) {
                self.result.addArtifact(fileHash);
                return artifact.save();
            })
            .then(function (artifactHash) {
                self.result.addArtifact(artifactHash);
                self.result.setSuccess(true);
                callback(null, self.result);
            })
            .catch(function (err) {
                self.logger.error(err.stack);
                // Result success is false at invocation.
                callback(err, self.result);
            });

    };

    RTCparser.prototype.loadNodeMap = function (node) {
        var self = this;
        return self.core.loadSubTree(node)
            .then(function (nodeArr) {
                var nodes = {},
                    i;
                for (i = 0; i < nodeArr.length; i += 1) {
                    nodes[self.core.getPath(nodeArr[i])] = nodeArr[i];
                }

                return nodes;
            });
    };

    var serviceSrc = new Map(),
        serviceDst = new Map(),
        arrivalSrc = new Map(),
        arrivalDst = new Map(),
        arrivalSrc2 = new Map(),
        arrivalDst2 = new Map(),
        isPrinted = new Map(),
        delayCnt = 1,
        bufCnt = 1,
        sRemain = 1;

    RTCparser.prototype.getInst = function (root, nodes){
        var self = this,
            thisNode,
            exampleNode,
            thisName,
            childrenPaths,
            i;

        var inst = '\n% MATLAB instructions \n\n';

        childrenPaths = self.core.getChildrenPaths(root); //get the children of root

        for (i = 0; i < childrenPaths.length; i += 1) {
            thisNode = nodes[childrenPaths[i]];
            thisName = self.core.getAttribute(thisNode, 'name');
            if (thisName == 'MPA_example'){
                exampleNode = thisNode;
            }
        }

        self.transConnection(exampleNode, nodes);

        inst = self.getInput(exampleNode, nodes, inst);

        inst = self.getControlFlow(exampleNode, nodes, inst);

        inst = self.getDraw(exampleNode, nodes, inst);

        return inst;

    }

    RTCparser.prototype.transConnection = function (root, nodes) {
        var self = this,
            thisNode,
            thisName,
            base,
            metaType,
            i;

        var childrenPaths = self.core.getChildrenPaths(root); // get the children of the example

        for (i = 0; i < childrenPaths.length; i += 1) {
            thisNode = nodes[childrenPaths[i]];
            thisName = self.core.getAttribute(thisNode, 'name');
            if (self.core.isConnection(thisNode)) {
                base = self.core.getBase(thisNode);
                metaType = self.core.getAttribute(base, 'name');
                var dstNode = self.core.getPointerPath(thisNode, 'dst');
                var srcNode = self.core.getPointerPath(thisNode, 'src');
                if (metaType == 'arrival'){
                    if (arrivalDst.get(nodes[dstNode]))
                        arrivalDst2.set(nodes[dstNode], i);
                    else
                        arrivalDst.set(nodes[dstNode], i);
                    if(arrivalSrc.get(nodes[srcNode]))
                        arrivalSrc2.set(nodes[srcNode], i);
                    else
                        arrivalSrc.set(nodes[srcNode], i);
                }else if (metaType == 'service'){
                    serviceSrc.set(nodes[srcNode], i);
                    serviceDst.set(nodes[dstNode], i);
                }
            }
        }

    }

    RTCparser.prototype.getInput = function (root, nodes, inst) {
        var self = this,
            thisNode, thisName,
            base, metaType, i;
        var P, J, D, B, S, info, connection;

        var childrenPaths = self.core.getChildrenPaths(root);
        for (i = 0; i < childrenPaths.length; i += 1) {
            thisNode = nodes[childrenPaths[i]];
            thisName = self.core.getAttribute(thisNode, 'name');
            base = self.core.getBase(thisNode);
            metaType = self.core.getAttribute(base, 'name');
            if (metaType == 'PJD' && arrivalSrc.get(thisNode)){ // as source, it has a connection
                P = self.core.getAttribute(thisNode, 'Period');
                J = self.core.getAttribute(thisNode, 'Jitter');
                D = self.core.getAttribute(thisNode, 'Distance');
                connection = self.core.getAttribute(
                    nodes[childrenPaths[arrivalSrc.get(thisNode)]], 'name');
                info = connection + ' = rtcpjd(' + P + ', ' + J + ', ' + D + '); \n';
                inst += info;
                isPrinted.set(thisNode, 1);
                isPrinted.set(nodes[childrenPaths[arrivalSrc.get(thisNode)]], 1);
                
            }else if (metaType == 'FS' && serviceSrc.get(thisNode)){ // as source, it has a connection
                B = self.core.getAttribute(thisNode, 'Bandwidth');
                connection = self.core.getAttribute(
                    nodes[childrenPaths[serviceSrc.get(thisNode)]], 'name');
                info = connection + ' = rtcfs(' + B + '); \n';
                inst += info;
                isPrinted.set(thisNode, 1);
                isPrinted.set(nodes[childrenPaths[serviceSrc.get(thisNode)]], 1);
            }else if (metaType == 'TDMA' && serviceSrc.get(thisNode)){
                P = self.core.getAttribute(thisNode, 'Period');
                B = self.core.getAttribute(thisNode, 'Bandwidth');
                S = self.core.getAttribute(thisNode, 'Slot');
                connection = self.core.getAttribute(
                    nodes[childrenPaths[serviceSrc.get(thisNode)]], 'name');
                info = connection + ' = rtctdma(' + S + ', ' + P + ', ' + B + '); \n';
                inst += info;
                isPrinted.set(thisNode, 1);
                isPrinted.set(nodes[childrenPaths[serviceSrc.get(thisNode)]], 1);
            }
        }

        inst += '\n';

        return inst;

    }

    RTCparser.prototype.getDraw = function (root, nodes, inst) {
        var self = this,
            thisNode, thisName,
            corNode, corName,
            startName, endName,
            base, metaType, i,j;

        var childrenPaths = self.core.getChildrenPaths(root);

        inst += 'figure;\n';

        var arrPlot = [];
        var cnt = 0;

        for (i = 0; i < childrenPaths.length; i += 1) {
            thisNode = nodes[childrenPaths[i]];
            thisName = self.core.getAttribute(thisNode, 'name');
            base = self.core.getBase(thisNode);
            metaType = self.core.getAttribute(base, 'name');
            if (metaType == 'PJD' && arrivalSrc.get(thisNode)){ // as source, it has a connection
                for (j = 0; j < childrenPaths.length; j += 1){
                    corNode = nodes[childrenPaths[j]];
                    corName = self.core.getAttribute(corNode, 'name');
                    if (corName == thisName && arrivalDst.get(corNode)){
                        startName = self.core.getAttribute(
                            nodes[childrenPaths[arrivalSrc.get(thisNode)]], 'name');
                        endName = self.core.getAttribute(
                            nodes[childrenPaths[arrivalDst.get(corNode)]], 'name');
                        arrPlot[cnt] = 'rtcplot(' + startName + ', \'b\', ' + endName + ', \'r\', 60); ';
                        arrPlot[cnt] += 'title(\'' + startName + ' (blue); ' + endName + ' (red)\');\n';
                        cnt++;
                    }
                }
            }
        }

        for (i=0; i < cnt; i++){
            inst += 'subplot(' + cnt + ', 1, ' + (i + 1) + '); ' + arrPlot[i];
        }

        return inst;
    }

    RTCparser.prototype.getControlFlow = function (root, nodes, inst) {
        var self = this,
            thisNode, i;

        var childrenPaths = self.core.getChildrenPaths(root);

        var flag = 1;
        while(flag){
            flag = 0;
            for (i = 0; i < childrenPaths.length; i += 1) {
                thisNode = nodes[childrenPaths[i]];
                if (!isPrinted.get(thisNode)){
                    inst = self.getNodeInfo(thisNode, nodes, childrenPaths, inst, 0);
                    flag = 1;
                }
            }
        }

        inst += '\n';

        return inst;
    }

    RTCparser.prototype.getNodeInfo = function (root, nodes, Paths, inst, indent) {
        if (isPrinted.get(root))
            return inst;

        var self = this,
            base, metaType, info, tmp;

        var aSrcLine, aSrcLineName,
            aSrcLine2, aSrcLineName2,
            sSrcLine, sSrcLineName,
            aDstLine, aDstLineName,
            aDstLine2, aDstLineName2,
            sDstLine, sDstLineName,
            e1, d1, e2, d2;

        base = self.core.getBase(root);
        metaType = self.core.getAttribute(base, 'name');
        if (metaType == 'EDF'){
            aSrcLine = nodes[Paths[arrivalDst.get(root)]];
            aSrcLine2 = nodes[Paths[arrivalDst2.get(root)]];
            sSrcLine = nodes[Paths[serviceDst.get(root)]];
            aSrcLineName = self.core.getAttribute(aSrcLine, 'name');
            aSrcLineName2 = self.core.getAttribute(aSrcLine2, 'name');
            sSrcLineName = self.core.getAttribute(sSrcLine, 'name');

            if(isPrinted.get(aSrcLine) && isPrinted.get(aSrcLine2)
                && isPrinted.get(sSrcLine)){
                aDstLine = nodes[Paths[arrivalSrc.get(root)]];
                aDstLine2 = nodes[Paths[arrivalSrc2.get(root)]];
                sDstLine = nodes[Paths[serviceSrc.get(root)]];

                aDstLineName = self.core.getAttribute(aDstLine, 'name');
                aDstLineName2 = self.core.getAttribute(aDstLine2, 'name');
                sDstLineName = self.core.getAttribute(sDstLine, 'name');
                e1 = self.core.getAttribute(aSrcLine, 'Demand');
                d1 = self.core.getAttribute(aSrcLine, 'Deadline');
                e2 = self.core.getAttribute(aSrcLine2, 'Demand');
                d2 = self.core.getAttribute(aSrcLine2, 'Deadline');

                info = '[' + aDstLineName + ', del' + delayCnt + ', buf' + bufCnt + ', ' +
                    aDstLineName2 + ', del' + (delayCnt + 1) + ', buf' + (bufCnt + 1) + ', ' + sDstLineName +
                    '] = rtcedf(' + aSrcLineName + ', ' + e1 + ', ' + d1 + ', ' +
                    aSrcLineName2 + ', ' + e2 + ', ' + d2 + ', ' + sSrcLineName + ');\n';

                isPrinted.set(aDstLine, 1);
                isPrinted.set(aDstLine2, 1);
                isPrinted.set(sDstLine, 1);
                delayCnt += 2;
                bufCnt += 2;
                inst += info;
                isPrinted.set(root, 1);

            }
        }
        else if (metaType == 'GPC'){
            aSrcLine = nodes[Paths[arrivalDst.get(root)]];
            sSrcLine = nodes[Paths[serviceDst.get(root)]];
            aSrcLineName = self.core.getAttribute(aSrcLine, 'name');
            sSrcLineName = self.core.getAttribute(sSrcLine, 'name');

            if(isPrinted.get(aSrcLine) && isPrinted.get(sSrcLine)){

                aDstLine = nodes[Paths[arrivalSrc.get(root)]];
                sDstLine = nodes[Paths[serviceSrc.get(root)]];

                aDstLineName = self.core.getAttribute(aDstLine, 'name');
                e1 = self.core.getAttribute(aSrcLine, 'Demand');

                if (sDstLine){
                    sDstLineName = self.core.getAttribute(sDstLine, 'name');
                    info = '[' + aDstLineName + ', ' + sDstLineName + ', del' + delayCnt + ', buf' + bufCnt +
                        '] = rtcgpc(' + aSrcLineName + ', ' + sSrcLineName + ', ' + e1 + ');\n';
                }else{
                    info = '[' + aDstLineName + ', br' + sRemain + ', del' + delayCnt + ', buf' + bufCnt +
                        '] = rtcgpc(' + aSrcLineName + ', ' + sSrcLineName + ', ' + e1 + ');\n';
                    sRemain += 1;
                }

                isPrinted.set(aDstLine, 1);
                isPrinted.set(sDstLine, 1);
                delayCnt += 1;
                bufCnt += 1;
                inst += info;
                isPrinted.set(root, 1);

            }
        }else if (metaType == 'PJD' && arrivalDst.get(root)){
            aSrcLine = nodes[Paths[arrivalDst.get(root)]];
            if(isPrinted.get(aSrcLine)){
                isPrinted.set(root, 1);
            }
        }

        return inst;
    }

    return RTCparser;
});