/*globals define*/
/*jshint node:true, browser:true*/

/**
 * Generated by PluginGenerator 1.7.0 from webgme on Wed Oct 19 2016 19:43:45 GMT-0500 (Central Daylight Time).
 * A plugin that inherits from the PluginBase. To see source code documentation about available
 * properties and methods visit %host%/docs/source/PluginBase.html.
 */
define([
        'plugin/PluginConfig',
        'text!./metadata.json',
        'plugin/PluginBase',
        'q'
],      function (PluginConfig,
                 pluginMetadata,
                 PluginBase,
                 Buffer) {
                'use strict';
        pluginMetadata = JSON.parse(pluginMetadata);
        /**
         * Initializes a new instance of MiniProject2.
         * @class
         * @augments {PluginBase}
         * @classdesc This class represents the plugin MiniProject2.
         * @constructor
         */
        var MiniProject2 = function ()
        {
            PluginBase.call(this);
            this.pluginMetadata = pluginMetadata;
        };
        /**
         * Metadata associated with the plugin. Contains id, Name, version, description, icon, configStructue etc.
         * This is also available at the instance at this.pluginMetadata.
         * @type {object}
         */
        MiniProject2.metadata = pluginMetadata;
        // Prototypical inheritance from PluginBase.
        MiniProject2.prototype = Object.create(PluginBase.prototype);
        MiniProject2.prototype.constructor = MiniProject2;
        /**
         * Main function for the plugin to execute. This will perform the execution.
         * Notes:
         * - Always log with the provided logger.[error,warning,info,debug].
         * - Do NOT put any user interaction logic UI, etc. inside this method.
         * - callback always has to be called even if error happened.
         *
         * @param {function(string, plugin.PluginResult)} callback - the result callback
         */
        MiniProject2.prototype.main = function (callback)
        {
            // Use self to access core, project, result, logger etc from PluginBase.
            // These are all instantiated at this point.
            var self = this,
                nodeObject,
                artifact;

            MiniProject2.prototype.loadNodeMap = function (node)
            {
                var self = this;
                return self.core.loadSubTree(node)
                    .then(function (nodeArr) {
                        var nodes = {},
                            x;
                        for (x = 0; x < nodeArr.length; x += 1)
                        {
                            nodes[self.core.getPath(nodeArr[x])] = nodeArr[x];
                        }
                        return nodes;
                    });
            };
            self.metaNodeInfo = [];
            // using the logger
            self.logger.debug('This is a debug message.');
            self.logger.info('This is an info message.');
            self.logger.warn('This is a warning message.');
            self.logger.error('This is an error message.');

            self.loadNodeMap(self.rootNode)
                .then(function (nodes)
                {
                    var jsonModel = self.buildTree(self.rootNode, nodes);
                    self.logger.info(JSON.stringify(jsonModel, null, 4));
                    return self.generateArtifact(jsonModel, self.metaNodeInfo);
                })
                .then(function (artifactHash)
                {
                    self.result.addArtifact(artifactHash);
                    self.result.setSuccess(true);
                    callback(null, self.result);
                })
                .catch(function (err)
                {
                    self.logger.error(err.stack);
                    callback(err, self.result);
                });
        }

        MiniProject2.prototype.buildTree = function (root, nodes)
        {
                var self = this,
                     childrenPaths,
                     Node_child,
                     isMetaNode,
                     metaNode,
                     metaPath,
                     x,
                     Path,
                     Name,
                     Connection = false,
                     src,
                     dst,
                     node_base,
                     connectStr = '';
            childrenPaths = self.core.getChildrenPaths(root);
            Name = self.core.getAttribute(root, 'Name');
            metaNode = self.getMetaType(root);

            node_base = self.core.getPointerPath(root, 'base');
            if (node_base !== null) {
                node_base = self.core.getAttribute(nodes[node_base], 'Name');
            }
            else
                node_base = "null";
            metaPath = self.core.getPath(metaNode);
            Path = self.core.getPath(root);
            isMetaNode = (metaPath === Path);

            // checking for connection in the nodes
            src = self.core.getPointerPath(root, 'src');
            dst = self.core.getPointerPath(root, 'dst');
            if (src && dst)
            {
                Connection = true;
                src = nodes[src];
                dst = nodes[dst];
                src = self.core.getAttribute(src, "Name");
                dst = self.core.getAttribute(dst, "Name");
                connectStr = src + " -> " + dst;
            }

            var jsonModel = {};
            jsonModel.Name = Name;
            var ckt_btype = self.core.getBaseType(root);
            var whenRoot = false;
            var NameMetaType = "";
            if (ckt_btype)
                NameMetaType = self.core.getAttribute(ckt_btype, 'Name');
            else
                whenRoot = true;

            if (!whenRoot)
            {
                jsonModel.isMeta = isMetaNode;
                jsonModel.metaType = NameMetaType;
                if (isMetaNode)
                {
                    self.metaNodeInfo.push({name: Name, path: Path, nbrOfChildren: childrenPaths.length, base: node_base});
                }
            }
            if (Connection)
            {
                var attributeNames = self.core.getAttributeNames(root);
                for (var x = 1; x < (attributeNames.length+1); x++)
                {
                    jsonModel[attributeNames[x]] = self.core.getAttribute(root, attributeNames[x]);
                }
                jsonModel.src = src;
                jsonModel.dst = dst;
            }
            else {
                var attributeNames = self.core.getAttributeNames(root);
                for (var x = 0; x < attributeNames.length; x++) {
                    jsonModel[attributeNames[x]] = self.core.getAttribute(root, attributeNames[x]);
                }
                jsonModel.children = {};
                for (x = 0; x < childrenPaths.length; x++)
                {
                    Node_child = nodes[childrenPaths[x]];
                    var cm = self.buildTree(Node_child, nodes);
                    var relPath = self.core.getRelid(Node_child);
                    jsonModel.children[relPath] = cm;
                }
            }
            return jsonModel;
        };
        MiniProject2.prototype.generateArtifact = function (tree, meta)
        {
            var self = this,
                deferred = Buffer.defer(),
                language,
                artifact,
                filesToAdd = {},
                codeFileName,
                batchFileName;
            artifact = self.blobClient.createArtifact('project-data');
            filesToAdd['Tree.json'] = JSON.stringify(tree, null, 4);
            filesToAdd['Meta.json'] = JSON.stringify(meta, null, 4);

            artifact.addFiles(filesToAdd, function (err)
            {
                if (err)
                {
                    deferred.reject(new Error(err));
                    return;
                }
                self.blobClient.saveAllArtifacts(function (err, hashes)
                {
                    if (err) {

                        deferred.reject(new Error(err));
                        return;
                    }
                    deferred.resolve(hashes[0]);
                });
            });
            return deferred.promise;
        };
        return MiniProject2;
    }
);